var documenterSearchIndex = {"docs":
[{"location":"interface/#interface","page":"Interface","title":"The ExponentialFamilyDistribution Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"This page describes the philosophy and design concepts behind the ExponentialFamilyDistribution interface. In a nutshell, the primary purpose of the ExponentialFamily package is to provide a generic interface for an ExponentialFamilyDistribution. It is beneficial to become familiar with the Wikipedia article on the exponential family before delving into the implementation details of this package.","category":"page"},{"location":"interface/#Notation","page":"Interface","title":"Notation","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"In the context of the package, exponential family distributions are represented in the form:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"f_X(xmideta) = h(x) cdot expleft eta cdot T(x) - A(eta) right","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Here:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"h(x) is the base measure.\nT(x) represents sufficient statistics.\nA(η) stands for the log partition.\nη denotes the natural parameters.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"In the following discussion we also use the following convention","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"η corresponds to the distribution's natural parameters in the natural parameter space.\nθ corresponds to the distribution's mean parameters in the mean parameter space.","category":"page"},{"location":"interface/#ExponentialFamilyDistribution-structure","page":"Interface","title":"ExponentialFamilyDistribution structure","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"ExponentialFamilyDistribution\nExponentialFamilyDistributionAttributes\nlogpdf(ef::ExponentialFamilyDistribution, x)\npdf(ef::ExponentialFamilyDistribution, x)\ncdf(ef::ExponentialFamilyDistribution{D}, x) where {D <: Distribution}\ngetnaturalparameters\ngetattributes\ngetconditioner\nisproper\ngetbasemeasure\ngetsufficientstatistics\ngetlogpartition\ngetgradlogpartition\ngetfisherinformation\ngetsupport\nbasemeasure\nsufficientstatistics\nlogpartition\ngradlogpartition\nfisherinformation\nisbasemeasureconstant\nConstantBaseMeasure\nNonConstantBaseMeasure\nExponentialFamily._logpdf\nExponentialFamily.check_logpdf\nExponentialFamily.PointBasedLogpdfCall\nExponentialFamily.MapBasedLogpdfCall","category":"page"},{"location":"interface/#ExponentialFamily.ExponentialFamilyDistribution","page":"Interface","title":"ExponentialFamily.ExponentialFamilyDistribution","text":"ExponentialFamilyDistribution(::Type{T}, naturalparameters, conditioner, attributes)\n\nExponentialFamilyDistribution structure represents a generic exponential family distribution in natural parameterization. Type T can be either a distribution type (e.g. from the Distributions.jl package) or a variate type (e.g. Univariate). In the context of the package, exponential family distributions are represented in the form:\n\npₓ(x  η) = h(x)  exp η  T(x) - A(η) \n\nHere:\n\nh(x) is the base measure.\nT(x) represents sufficient statistics.\nA(η) stands for the log partition.\nη denotes the natural parameters.\n\nFor a given member of exponential family: \n\ngetattributes returns either nothing or ExponentialFamilyDistributionAttributes.\ngetbasemeasure returns a positive a valued function. \ngetsufficientstatistics returns an iterable of functions such as [x, x^2] or [x, logx].\ngetnaturalparameters returns an iterable holding the values of the natural parameters. \ngetlogpartition return a function that depends on the naturalparameters and it ensures that the distribution is normalized to 1. \ngetsupport returns the set that the distribution is defined over. Could be real numbers, positive integers, 3d cube etc. Use ither the ∈ operator or the insupport() function to check if a value belongs to the support.\n\nnote: Note\nThe attributes can be nothing. In which case the package will try to derive the corresponding attributes from the type T.\n\njulia> ef = convert(ExponentialFamilyDistribution, Bernoulli(0.5))\nExponentialFamily(Bernoulli)\n\njulia> getsufficientstatistics(ef)\n(identity,)\n\njulia> ef = convert(ExponentialFamilyDistribution, Laplace(1.0, 0.5))\nExponentialFamily(Laplace, conditioned on 1.0)\n\njulia> logpdf(ef, 4.0)\n-6.0\n\nSee also: getbasemeasure, getsufficientstatistics, getnaturalparameters, getlogpartition, getsupport\n\n\n\n\n\n","category":"type"},{"location":"interface/#ExponentialFamily.ExponentialFamilyDistributionAttributes","page":"Interface","title":"ExponentialFamily.ExponentialFamilyDistributionAttributes","text":"ExponentialFamilyDistributionAttributes(basemeasure, sufficientstatistics, logpartition, support)\n\nA structure to represent the attributes of an exponential family member.\n\nFields\n\nbasemeasure::B: The basemeasure of the exponential family member.\nsufficientstatistics::S: The sufficient statistics of the exponential family member.\nlogpartition::L: The log-partition (cumulant) of the exponential family member.\nsupport::P: The support of the exponential family member.\n\nSee also: ExponentialFamilyDistribution, getbasemeasure, getsufficientstatistics, getlogpartition, getsupport\n\n\n\n\n\n","category":"type"},{"location":"interface/#Distributions.logpdf-Tuple{ExponentialFamilyDistribution, Any}","page":"Interface","title":"Distributions.logpdf","text":"logpdf(ef::ExponentialFamilyDistribution, x)\n\nEvaluates and returns the log-density of the exponential family distribution for the input x.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Distributions.pdf-Tuple{ExponentialFamilyDistribution, Any}","page":"Interface","title":"Distributions.pdf","text":"pdf(ef::ExponentialFamilyDistribution, x)\n\nEvaluates and returns the probability density function of the exponential family distribution for the input x.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Distributions.cdf-Union{Tuple{D}, Tuple{ExponentialFamilyDistribution{D}, Any}} where D<:Distribution","page":"Interface","title":"Distributions.cdf","text":"cdf(ef::ExponentialFamilyDistribution{D}, x) where { D <: Distribution }\n\nEvaluates and returns the cumulative distribution function of the exponential family distribution for the input x.\n\n\n\n\n\n","category":"method"},{"location":"interface/#ExponentialFamily.getnaturalparameters","page":"Interface","title":"ExponentialFamily.getnaturalparameters","text":"getnaturalparameters(::ExponentialFamilyDistribution)\n\nGet the natural parameters of the exponential family distribution.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.getattributes","page":"Interface","title":"ExponentialFamily.getattributes","text":"getattributes(::ExponentialFamilyDistribution)\n\nReturns iether the attributes of the exponential family member or nothing. \n\nSee also: ExponentialFamilyDistributionAttributes\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.getconditioner","page":"Interface","title":"ExponentialFamily.getconditioner","text":"getconditioner(::ExponentialFamilyDistribution)\n\nReturns either the conditioner of the exponential family distribution or nothing. conditioner is a fixed parameter that is used to ensure that the distribution belongs to the exponential family.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.isproper","page":"Interface","title":"ExponentialFamily.isproper","text":"isproper(::ExponentialFamilyDistribution)\n\nChecks if the object of type ExponentialFamilyDistribution is a proper distribution.\n\n\n\n\n\nisproper([ space = NaturalParametersSpace() ], ::Type{T}, parameters, conditioner = nothing) where { T <: Distribution }\n\nA specific verion of isproper defined particularly for distribution types from Distributions.jl package. Does not require an instance of the ExponentialFamilyDistribution and can be called directly with a specific distribution type instead. Optionally, accepts the space parameter, which defines the parameters space. For conditional exponential family distributions requires an extra conditioner argument.\n\nSee also: NaturalParametersSpace, MeanParametersSpace\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.getbasemeasure","page":"Interface","title":"ExponentialFamily.getbasemeasure","text":"getbasemeasure(::ExponentialFamilyDistribution)\ngetbasemeasure(::Type{ <: Distribution }, [ conditioner ])\n\nReturns the base measure function of the exponential family distribution.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.getsufficientstatistics","page":"Interface","title":"ExponentialFamily.getsufficientstatistics","text":"getsufficientstatistics(::ExponentialFamilyDistribution)\ngetsufficientstatistics(::Type{ <: Distribution }, [ conditioner ])\n\nReturns the list of sufficient statistics of the exponential family distribution.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.getlogpartition","page":"Interface","title":"ExponentialFamily.getlogpartition","text":"getlogpartition(::ExponentialFamilyDistribution)\ngetlogpartition([ space ], ::Type{ <: Distribution }, [ conditioner ])\n\nReturns the log partition function of the exponential family distribution.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.getgradlogpartition","page":"Interface","title":"ExponentialFamily.getgradlogpartition","text":"getgradlogpartition([ space = NaturalParametersSpace() ], ::Type{T}, [ conditioner ]) where { T <: Distribution }\n\nA specific verion of getgradlogpartition defined particularly for distribution types from Distributions.jl package. Does not require an instance of the ExponentialFamilyDistribution and can be called directly with a specific distribution type instead. Optionally, accepts the space parameter, which defines the parameters space. For conditional exponential family distributions requires an extra conditioner argument.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.getfisherinformation","page":"Interface","title":"ExponentialFamily.getfisherinformation","text":"getfisherinformation(::ExponentialFamilyDistribution)\ngetfisherinformation([ space ], ::Type{ <: Distribution }, [ conditioner ])\n\nReturns the function that computes the fisher information matrix of the exponential family distribution.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.getsupport","page":"Interface","title":"ExponentialFamily.getsupport","text":"getsupport(distribution_or_type)\n\nReturns the support of the exponential family distribution.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.basemeasure","page":"Interface","title":"ExponentialFamily.basemeasure","text":"basemeasure(::ExponentialFamilyDistribution, x)\n\nReturns the computed value of basemeasure of the exponential family distribution at the point x.\n\nSee also: getbasemeasure\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.sufficientstatistics","page":"Interface","title":"ExponentialFamily.sufficientstatistics","text":"sufficientstatistics(::ExponentialFamilyDistribution)\n\nReturns the computed values of sufficientstatistics of the exponential family distribution at the point x.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.logpartition","page":"Interface","title":"ExponentialFamily.logpartition","text":"logpartition(::ExponentialFamilyDistribution, η)\n\nReturn the computed value of logpartition of the exponential family distribution at the point η. By default η = getnaturalparameters(ef).\n\nSee also: getlogpartition\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.gradlogpartition","page":"Interface","title":"ExponentialFamily.gradlogpartition","text":"gradlogpartition(::ExponentialFamilyDistribution, η)\n\nReturn the computed value of gradlogpartition of the exponential family distribution at the point η. By default η = getnaturalparameters(ef).\n\nSee also: getgradlogpartition\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.fisherinformation","page":"Interface","title":"ExponentialFamily.fisherinformation","text":"fisherinformation(distribution, η)\n\nReturn the computed value of fisherinformation of the exponential family distribution at the point η By default η = getnaturalparameters(ef).\n\nSee also: getfisherinformation\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.isbasemeasureconstant","page":"Interface","title":"ExponentialFamily.isbasemeasureconstant","text":"isbasemeasureconstant(something)\n\nReturns either NonConstantBaseMeasure() or ConstantBaseMeasure() depending on if the base measure is a constant with respect to the natural parameters of something or not. By default the package assumes that any base measure in a form of the Function is not a constant. It, however, is not true for basemeasure that simply return a constant. In such cases the isbasemeasureconstant must have a specific method.\n\nSee also: getbasemeasure, basemeasure\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.ConstantBaseMeasure","page":"Interface","title":"ExponentialFamily.ConstantBaseMeasure","text":"A trait object representing that the base measure is constant.\n\n\n\n\n\n","category":"type"},{"location":"interface/#ExponentialFamily.NonConstantBaseMeasure","page":"Interface","title":"ExponentialFamily.NonConstantBaseMeasure","text":"A trait object representing that the base measure is not constant.\n\n\n\n\n\n","category":"type"},{"location":"interface/#ExponentialFamily._logpdf","page":"Interface","title":"ExponentialFamily._logpdf","text":"_logpdf(ef::ExponentialFamilyDistribution, x)\n\nEvaluates and returns the log-density of the exponential family distribution for the input x.\n\nThis inner function dispatches to the appropriate version of _logpdf based on the types of x and ef, utilizing the check_logpdf function. The dispatch mechanism ensures that _logpdf correctly handles the input x, whether it is a single point or a container of points, according to the nature of the exponential family distribution and x.\n\nFor instance, with a Univariate distribution, _logpdf evaluates the log-density for a single point if x is a Number, and for a container of points if x is an AbstractVector.\n\nExamples\n\nEvaluate the log-density of a Gamma distribution at a single point:\n\nusing ExponentialFamily, Distributions;\ngamma = convert(ExponentialFamilyDistribution, Gamma(1, 1))\nExponentialFamily._logpdf(gamma, 1.0)\n# output\n-1.0\n\nEvaluate the log-density of a Gamma distribution at multiple points:\n\nusing ExponentialFamily, Distributions\ngamma = convert(ExponentialFamilyDistribution, Gamma(1, 1))\nExponentialFamily._logpdf(gamma, [1, 2, 3])\n# output\n3-element Vector{Float64}:\n -1.0\n -2.0\n -3.0\n\nFor details on the dispatch mechanism of _logpdf, refer to the check_logpdf function.\n\nSee also: check_logpdf\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.check_logpdf","page":"Interface","title":"ExponentialFamily.check_logpdf","text":"check_logpdf(variate_form, typeof(x), eltype(x), ef, x)\n\nDetermines an appropriate strategy of evaluation of _logpdf (PointBasedLogpdfCall or MapBasedLogpdfCall) to use based on the types of x and ef. This function employs a dispatch mechanism that adapts to the input x, whether it is a single point or a container of points, in accordance with the characteristics of the exponential family distribution (ef) and the variate form of x.\n\nStrategies\n\nFor a Univariate distribution:\nIf x is a Number, _logpdf is invoked with PointBasedLogpdfCall().\nIf x is an AbstractVector containing Numbers, _logpdf is invoked with MapBasedLogpdfCall().\nFor a Multivariate distribution:\nIf x is an AbstractVector containing Numbers, _logpdf is invoked with PointBasedLogpdfCall().\nIf x is an AbstractVector containing AbstractVectors, _logpdf is invoked with MapBasedLogpdfCall().\nIf x is an AbstractMatrix containing Numbers, _logpdf is invoked with MapBasedLogpdfCall(), transforming x to eachcol(x).\nFor a Matrixvariate distribution:\nIf x is an AbstractMatrix containing Numbers, _logpdf is invoked with PointBasedLogpdfCall().\nIf x is an AbstractVector containing AbstractMatrixs, _logpdf is invoked with MapBasedLogpdfCall().\n\nExamples\n\nusing ExponentialFamily\nExponentialFamily.check_logpdf(Univariate, typeof(1.0), eltype(1.0), Gamma(1, 1), 1.0)\n# output\n(ExponentialFamily.PointBasedLogpdfCall(), 1.0)\n\nusing ExponentialFamily\nExponentialFamily.check_logpdf(Univariate, typeof([1.0, 2.0, 3.0]), eltype([1.0, 2.0, 3.0]), Gamma(1, 1), [1.0, 2.0, 3.0])\n# output\n(ExponentialFamily.MapBasedLogpdfCall(), [1.0, 2.0, 3.0])\n\nSee also: _logpdf PointBasedLogpdfCall MapBasedLogpdfCall\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.PointBasedLogpdfCall","page":"Interface","title":"ExponentialFamily.PointBasedLogpdfCall","text":"A trait object, signifying that the _logpdf method should treat it second argument as one point from the distrubution domain.\n\n\n\n\n\n","category":"type"},{"location":"interface/#ExponentialFamily.MapBasedLogpdfCall","page":"Interface","title":"ExponentialFamily.MapBasedLogpdfCall","text":"A trait object, signifying that the _logpdf method should treat it second argument as a container of points from the distrubution domain.\n\n\n\n\n\n","category":"type"},{"location":"interface/#Interfacing-with-Distributions-Defined-in-the-Distributions.jl-Package","page":"Interface","title":"Interfacing with Distributions Defined in the Distributions.jl Package","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The Distributions.jl package is a comprehensive library that defines a wide collection of standard distributions. The main objective of the Distributions package is to offer a unified interface for evaluating likelihoods of various distributions, along with convenient sampling routines from these distributions. The ExponentialFamily package provides a lightweight interface for a subset of the distributions defined in the Distributions package.","category":"page"},{"location":"interface/#Conversion-between-Mean-Parameters-Space-and-Natural-Parameters-Space","page":"Interface","title":"Conversion between Mean Parameters Space and Natural Parameters Space","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The Distributions package introduces the params function, which allows the retrieval of parameters for different distributions. For example:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"using Distributions, ExponentialFamily\n\ndistribution = Bernoulli(0.25)\n\ntuple_of_θ = params(distribution)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"These parameters are typically defined in what's known as the mean parameters space. However, the ExponentialFamilyDistribution expects parameters to be in the natural parameters space. To facilitate conversion between these two representations, the ExponentialFamily package provides two structures:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"MeanToNatural\nNaturalToMean\nExponentialFamily.getmapping","category":"page"},{"location":"interface/#ExponentialFamily.MeanToNatural","page":"Interface","title":"ExponentialFamily.MeanToNatural","text":"MeanToNatural(::Type{T})\n\nReturn the transformation function that maps the parameters in the mean parameters space to the natural parameters space for a distribution of type T. The transformation function is of signature (params_in_mean_space, [ conditioner ]) -> params_in_natural_space.\n\nSee also: NaturalToMean, NaturalParametersSpace, MeanParametersSpace, getmapping\n\n\n\n\n\n","category":"type"},{"location":"interface/#ExponentialFamily.NaturalToMean","page":"Interface","title":"ExponentialFamily.NaturalToMean","text":"NaturalToMean(::Type{T})\n\nReturn the transformation function that maps the parameters in the natural parameters space to the mean parameters space for a distribution of type T. The transformation function is of signature (params_in_natural_space, [ conditioner ]) -> params_in_mean_space.\n\nSee also: MeanToNatural, NaturalParametersSpace, MeanParametersSpace, getmapping\n\n\n\n\n\n","category":"type"},{"location":"interface/#ExponentialFamily.getmapping","page":"Interface","title":"ExponentialFamily.getmapping","text":"getmapping(::Pair{L, R}, T)\n\nReturns a transformation L -> R between different parametrizations of a distribution of type T.\n\nSee also: NaturalParametersSpace, MeanParametersSpace, NaturalToMean, MeanToNatural\n\n\n\n\n\n","category":"function"},{"location":"interface/","page":"Interface","title":"Interface","text":"To convert from the mean parameters space to the corresponding natural parameters space, you can use the following code:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"tuple_of_η = MeanToNatural(Bernoulli)(tuple_of_θ)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"And to convert back:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"tuple_of_θ = NaturalToMean(Bernoulli)(tuple_of_η)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Alternatuvely, the following API is supported ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"map(MeanParametersSpace() => NaturalParametersSpace(), Bernoulli, tuple_of_θ)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"map(NaturalParametersSpace() => MeanParametersSpace(), Bernoulli, tuple_of_η)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"While the ExponentialFamily package employs the respective mappings where needed, it's also possible to call these functions manually. For instance, the generic implementation of the convert function between ExponentialFamilyDistribution and Distribution is built in terms of MeanToNatural and NaturalToMean. Moreover, the convert function performs checks to ensure that the provided parameters and conditioner are suitable for a specific distribution type.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"isproper(::Type{T}, parameters, conditioner = nothing) where { T <: Distribution }","category":"page"},{"location":"interface/#ExponentialFamily.isproper-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Any}} where T<:Distribution","page":"Interface","title":"ExponentialFamily.isproper","text":"isproper([ space = NaturalParametersSpace() ], ::Type{T}, parameters, conditioner = nothing) where { T <: Distribution }\n\nA specific verion of isproper defined particularly for distribution types from Distributions.jl package. Does not require an instance of the ExponentialFamilyDistribution and can be called directly with a specific distribution type instead. Optionally, accepts the space parameter, which defines the parameters space. For conditional exponential family distributions requires an extra conditioner argument.\n\nSee also: NaturalParametersSpace, MeanParametersSpace\n\n\n\n\n\n","category":"method"},{"location":"interface/#Note-on-the-conditioned-distributions","page":"Interface","title":"Note on the conditioned distributions","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"For the conditioned distributions, two additional functions separate_conditioner and join_conditioner are used to separate the conditioner and actual parameters returned from the Distributions.params function.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"ExponentialFamily.separate_conditioner\nExponentialFamily.join_conditioner","category":"page"},{"location":"interface/#ExponentialFamily.separate_conditioner","page":"Interface","title":"ExponentialFamily.separate_conditioner","text":"separate_conditioner(::Type{T}, params) where {T <: Distribution}\n\nSeparates the conditioner argument from params and returns a tuple of (conditioned_params, conditioner). By default returns (params, nothing) but can be overwritten for certain distributions.\n\njulia> (cparams, conditioner) = ExponentialFamily.separate_conditioner(Laplace, (0.0, 1.0))\n((1.0,), 0.0)\n\njulia> params = ExponentialFamily.join_conditioner(Laplace, cparams, conditioner)\n(0.0, 1.0)\n\njulia> Laplace(params...) == Laplace(0.0, 1.0)\ntrue\n\nSee also: ExponentialFamily.join_conditioner\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.join_conditioner","page":"Interface","title":"ExponentialFamily.join_conditioner","text":"join_conditioner(::Type{T}, params, conditioner) where { T <: Distribution }\n\nJoins the conditioner argument with the params and returns a tuple of joined params, such that it can be used in a constructor of the T distribution.\n\njulia> (cparams, conditioner) = ExponentialFamily.separate_conditioner(Laplace, (0.0, 1.0))\n((1.0,), 0.0)\n\njulia> params = ExponentialFamily.join_conditioner(Laplace, cparams, conditioner)\n(0.0, 1.0)\n\njulia> Laplace(params...) == Laplace(0.0, 1.0)\ntrue\n\nSee also: ExponentialFamily.separate_conditioner\n\n\n\n\n\n","category":"function"},{"location":"interface/","page":"Interface","title":"Interface","text":"For example, Laplace distribution defines the functions in the following way","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"# `params` are coming from the `Distribution.params(::Laplace)` and return (location, scale)\n# The `location`, however is a fixed parameter in the exponential distribution representation of Laplace\n# Hence, we return a tuple of tuple of actual parameter and the conditioner\nfunction separate_conditioner(::Type{Laplace}, params)\n    location, scale = params\n    return ((scale, ), location)\nend\n\n# The `join_conditioner` must join the actual parameters and the conditioner in such a way, that it is compatible \n# with the `Laplace` structure from the `Distributions.jl`. In Laplace, the location parameter goes first.\nfunction join_conditioner(::Type{Laplace}, cparams, conditioner) \n    (scale, ) = cparams\n    location = conditioner\n    return (location, scale)\nend","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"In general, all functions defined for the ExponentialFamilyDistribution, such as getlogpartition or getbasemeasure accept an optional conditioner parameter, which is assumed to be nothing.  Conditioned distribution implement the \"conditioned\" versions of such functions by explicitly requiring the conditioner parameter, e.g.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"getsufficientstatistics(Laplace, 1.0) # explicit `conditioner = 1.0`","category":"page"},{"location":"interface/#Efficient-packing-of-the-natural-parameters-into-a-vectorized-form","page":"Interface","title":"Efficient packing of the natural parameters into a vectorized form","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The ExponentialFamilyDistribution type stores its natural parameters in a vectorized, or packed, format. This is done for the sake of efficiency and to enhance compatibility with autodiff packages like ForwardDiff, which anticipate a single parameter vector. As a result, the tuple of natural parameters needs to be converted to its corresponding vectorized form and vice versa. To achieve this, the package provides the flatten_parameters, pack_parameters and unpack_parameters functions.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"ExponentialFamily.flatten_parameters\nExponentialFamily.pack_parameters\nExponentialFamily.unpack_parameters","category":"page"},{"location":"interface/#ExponentialFamily.flatten_parameters","page":"Interface","title":"ExponentialFamily.flatten_parameters","text":"flatten_parameters(::Type{T}, params::Tuple)\n\nThis function returns the parameters of a distribution of type T in a flattened form without actually allocating the container.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.pack_parameters","page":"Interface","title":"ExponentialFamily.pack_parameters","text":"pack_parameters([ space ], ::Type{T}, params::Tuple)\n\nThis function returns the parameters of a distribution of type T in a vectorized (packed) form. For most of the distributions the packed versions are of the  same structure in any parameters space. For some distributions, however, it is necessary to indicate the space of the packaged parameters.\n\njulia> ExponentialFamily.pack_parameters((1, [2.0, 3.0], [4.0 5.0 6.0; 7.0 8.0 9.0]))\n9-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n 4.0\n 7.0\n 5.0\n 8.0\n 6.0\n 9.0\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.unpack_parameters","page":"Interface","title":"ExponentialFamily.unpack_parameters","text":"unpack_parameters([ space ], ::Type{T}, parameters)\n\nThis function \"unpack\" the vectorized form of the parameters in a tuple. For most of the distributions the packed parameters are of the  same structure in any parameters space. For some distributions, however, it is necessary to indicate the space of the packaged parameters.\n\nSee also: MeanParametersSpace, NaturalParametersSpace\n\n\n\n\n\n","category":"function"},{"location":"interface/","page":"Interface","title":"Interface","text":"These functions are not exported by default, but it's important to note that the ExponentialFamilyDistributions type doesn't actually store the parameter tuple internally. Instead, the getnaturalparameters function returns the corresponding vectorized (packed) form of the natural parameters. In general, only the ExponentialFamily.unpack_parameters function must be implemented, as others could be implemented in a generic way.","category":"page"},{"location":"interface/#Attributes-of-the-exponential-family-distribution-based-on-Distribution","page":"Interface","title":"Attributes of the exponential family distribution based on Distribution","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The ExponentialFamilyDistribution{T} where { T <: Distribution } type encompasses all fundamental attributes of the exponential family, including basemeasure, logpartition, sufficientstatistics, and fisherinformation. Furthermore, it's possible to retrieve the actual functions that compute these attributes. For instance, consider the following example:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"basemeasure_of_bernoilli = getbasemeasure(Bernoulli)\n\nbasemeasure_of_bernoilli(0)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"isproper(::Type{T}, parameters, conditioner) where {T <: Distribution}\ngetbasemeasure(::Type{T}, ::Nothing) where {T <: Distribution}\ngetsufficientstatistics(::Type{T}, ::Nothing) where { T <: Distribution }\ngetlogpartition(::Type{T}, _) where { T <: Distribution }\ngetfisherinformation(::Type{T}, _) where { T <: Distribution }","category":"page"},{"location":"interface/#ExponentialFamily.isproper-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T<:Distribution","page":"Interface","title":"ExponentialFamily.isproper","text":"isproper([ space = NaturalParametersSpace() ], ::Type{T}, parameters, conditioner = nothing) where { T <: Distribution }\n\nA specific verion of isproper defined particularly for distribution types from Distributions.jl package. Does not require an instance of the ExponentialFamilyDistribution and can be called directly with a specific distribution type instead. Optionally, accepts the space parameter, which defines the parameters space. For conditional exponential family distributions requires an extra conditioner argument.\n\nSee also: NaturalParametersSpace, MeanParametersSpace\n\n\n\n\n\n","category":"method"},{"location":"interface/#ExponentialFamily.getbasemeasure-Union{Tuple{T}, Tuple{Type{T}, Nothing}} where T<:Distribution","page":"Interface","title":"ExponentialFamily.getbasemeasure","text":"getbasemeasure(::Type{<:Distribution}, [ conditioner ])\n\nA specific verion of getbasemeasure defined particularly for distribution types from Distributions.jl package. Does not require an instance of the ExponentialFamilyDistribution and can be called directly with a specific distribution type instead. For conditional exponential family distributions requires an extra conditioner argument.\n\n\n\n\n\n","category":"method"},{"location":"interface/#ExponentialFamily.getsufficientstatistics-Union{Tuple{T}, Tuple{Type{T}, Nothing}} where T<:Distribution","page":"Interface","title":"ExponentialFamily.getsufficientstatistics","text":"getsufficientstatistics(::Type{<:Distribution}, [ conditioner ])\n\nA specific verion of getsufficientstatistics defined particularly for distribution types from Distributions.jl package. Does not require an instance of the ExponentialFamilyDistribution and can be called directly with a specific distribution type instead. For conditional exponential family distributions requires an extra conditioner argument.\n\n\n\n\n\n","category":"method"},{"location":"interface/#ExponentialFamily.getlogpartition-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Distribution","page":"Interface","title":"ExponentialFamily.getlogpartition","text":"getlogpartition([ space = NaturalParametersSpace() ], ::Type{T}, [ conditioner ]) where { T <: Distribution }\n\nA specific verion of getlogpartition defined particularly for distribution types from Distributions.jl package. Does not require an instance of the ExponentialFamilyDistribution and can be called directly with a specific distribution type instead. Optionally, accepts the space parameter, which defines the parameters space. For conditional exponential family distributions requires an extra conditioner argument.\n\nSee also: NaturalParametersSpace, MeanParametersSpace\n\n\n\n\n\n","category":"method"},{"location":"interface/#ExponentialFamily.getfisherinformation-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Distribution","page":"Interface","title":"ExponentialFamily.getfisherinformation","text":"getfisherinformation([ space = NaturalParametersSpace() ], ::Type{T}) where { T <: Distribution }\n\nA specific verion of getfisherinformation defined particularly for distribution types from Distributions.jl package. Does not require an instance of the ExponentialFamilyDistribution and can be called directly with a specific distribution type instead. Optionally, accepts the space parameter, which defines the parameters space. For conditional exponential family distributions requires an extra conditioner argument.\n\nSee also: NaturalParametersSpace, MeanParametersSpace\n\n\n\n\n\n","category":"method"},{"location":"interface/","page":"Interface","title":"Interface","text":"Certain functions require knowledge about which parameter space is being used. By default, the NaturalParametersSpace is assumed.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"getlogpartition(Bernoulli) === getlogpartition(NaturalParametersSpace(), Bernoulli)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"NaturalParametersSpace\nMeanParametersSpace","category":"page"},{"location":"interface/#ExponentialFamily.NaturalParametersSpace","page":"Interface","title":"ExponentialFamily.NaturalParametersSpace","text":"NaturalParametersSpace\n\nSpecifies the natural parameters space η as the desired parameters space. Some functions (such as logpartition or fisherinformation) accept an additional space parameter to disambiguate the desired parameters space.  Use map(NaturalParametersSpace() => MeanParametersSpace(), T, parameters, conditioner) to map the parameters and the conditioner of a distribution of type T from the natural parametrization to the corresponding mean parametrization.\n\nSee also: MeanParametersSpace, getmapping, NaturalToMean, MeanToNatural\n\n\n\n\n\n","category":"type"},{"location":"interface/#ExponentialFamily.MeanParametersSpace","page":"Interface","title":"ExponentialFamily.MeanParametersSpace","text":"MeanParametersSpace\n\nSpecifies the mean parameters space θ as the desired parameters space. Some functions (such as logpartition or fisherinformation) accept an additional space parameter to disambiguate the desired parameters space.  Use map(MeanParametersSpace() => NaturalParametersSpace(), T, parameters, conditioner) to map the parameters and the conditioner of a distribution of type T from the mean parametrization to the corresponding natural parametrization.\n\nSee also: NaturalParametersSpace, getmapping, NaturalToMean, MeanToNatural\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"Interface","title":"Interface","text":"The isbasemeasureconstant function is defined for all supported distributions as well.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"isbasemeasureconstant(Bernoulli)","category":"page"},{"location":"interface/#Extra-defined-distributions","page":"Interface","title":"Extra defined distributions","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The package defines a list of extra distributions for a purpose of more efficiency in different circumstances. The list is available here.","category":"page"},{"location":"library/#library","page":"Library","title":"Library API","text":"","category":"section"},{"location":"library/#library-list-distributions-extra","page":"Library","title":"Additional distributions","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"These are the distributions that are not included in the Distributions.jl package.","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"ExponentialFamily.MatrixDirichlet\nExponentialFamily.GammaShapeRate\nExponentialFamily.GammaShapeScale\nExponentialFamily.NormalMeanPrecision\nExponentialFamily.NormalMeanVariance\nExponentialFamily.NormalWeightedMeanPrecision\nExponentialFamily.MvNormalMeanPrecision\nExponentialFamily.MvNormalMeanCovariance\nExponentialFamily.MvNormalWeightedMeanPrecision\nExponentialFamily.JointNormal\nExponentialFamily.JointGaussian\nExponentialFamily.WishartFast\nExponentialFamily.InverseWishartFast\nExponentialFamily.NormalGamma\nExponentialFamily.MvNormalWishart","category":"page"},{"location":"library/#ExponentialFamily.MatrixDirichlet","page":"Library","title":"ExponentialFamily.MatrixDirichlet","text":"MatrixDirichlet{T <: Real, A <: AbstractMatrix{T}} <: ContinuousMatrixDistribution\n\nA matrix-valued MatrixDirichlet distribution, where T is the element type of the matrix A. The a field stores the matrix parameter of the distribution.\n\nFields\n\na::A: The matrix parameter of the MatrixDirichlet distribution.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.GammaShapeRate","page":"Library","title":"ExponentialFamily.GammaShapeRate","text":"GammaShapeRate{T <: Real}\n\nA univariate gamma distribution parametrized by its shape a and rate b.\n\nFields\n\na: The shape parameter of the gamma distribution. It should be a positive real number.\nb: The rate parameter of the gamma distribution. It should be a positive real number.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.GammaShapeScale","page":"Library","title":"ExponentialFamily.GammaShapeScale","text":"GammaShapeScale{T}\n\nA continuous univariate gamma distribution parametrized by its shape α and scale β parameters.\n\nFields\n\nα: The shape parameter of the gamma distribution. It should be a positive real number.\nβ: The scale parameter of the gamma distribution. It should be a positive real number.\n\nNote\n\nGammaShapeScale is an alias for Gamma from Distributions.jl.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.NormalMeanPrecision","page":"Library","title":"ExponentialFamily.NormalMeanPrecision","text":"NormalMeanPrecision{T <: Real} <: ContinuousUnivariateDistribution\n\nA normal distribution with a known mean μ and precision w.\n\nFields\n\nμ::T: The mean of the normal distribution.\nw::T: The precision of the normal distribution.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.NormalMeanVariance","page":"Library","title":"ExponentialFamily.NormalMeanVariance","text":"NormalMeanVariance{T <: Real} <: ContinuousUnivariateDistribution\n\nA normal distribution with a known mean μ and variance v.\n\nFields\n\nμ::T: The mean of the normal distribution.\nv::T: The variance of the normal distribution.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.NormalWeightedMeanPrecision","page":"Library","title":"ExponentialFamily.NormalWeightedMeanPrecision","text":"NormalWeightedMeanPrecision{T <: Real} <: ContinuousUnivariateDistribution\n\nA normal distribution parametrized by its natural parameters: the weighted mean xi and precision w.\n\nFields\n\nxi::T: The weighted mean of the normal distribution. xi is computed as w * μ, where μ is the mean of the distribution.\nw::T: The precision (inverse variance) of the normal distribution.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.MvNormalMeanPrecision","page":"Library","title":"ExponentialFamily.MvNormalMeanPrecision","text":"MvNormalMeanPrecision{T <: Real, M <: AbstractVector{T}, P <: AbstractMatrix{T}} <: AbstractMvNormal\n\nA multivariate normal distribution with mean μ and precision matrix Λ, where T is the element type of the vectors M and matrices P.\n\nFields\n\nμ::M: The mean vector of the multivariate normal distribution.\nΛ::P: The precision matrix (inverse of the covariance matrix) of the multivariate normal distribution.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.MvNormalMeanCovariance","page":"Library","title":"ExponentialFamily.MvNormalMeanCovariance","text":"MvNormalMeanCovariance{T <: Real, M <: AbstractVector{T}, P <: AbstractMatrix{T}} <: AbstractMvNormal\n\nA multivariate normal distribution with mean μ and covariance matrix Σ, where T is the element type of the vectors M and matrices P.\n\nFields\n\nμ::M: The mean vector of the multivariate normal distribution.\nΣ::P: The covariance matrix of the multivariate normal distribution\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.MvNormalWeightedMeanPrecision","page":"Library","title":"ExponentialFamily.MvNormalWeightedMeanPrecision","text":"MvNormalWeightedMeanPrecision{T <: Real, M <: AbstractVector{T}, P <: AbstractMatrix{T}} <: AbstractMvNormal\n\nA multivariate normal distribution with a weighted mean vector xi and precision matrix Λ, where T is the element type of the vectors M and matrices P. This struct represents a natural parametrization of a multivariate Gaussian distribution.\n\nFields\n\nxi::M: The weighted mean vector of the multivariate normal distribution.\nΛ::P: The precision matrix (inverse of the covariance matrix) of the multivariate normal distribution.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.JointNormal","page":"Library","title":"ExponentialFamily.JointNormal","text":"JointNormal{D, S}\n\nJointNormal is an auxilary structure used for the joint marginal over Normally distributed variables. JointNormal stores a vector with the original dimensionalities (ds), so statistics can later be re-separated.\n\nUse ExponentialFamily.getcomponent(joint, index) to get a specific component of the joint distribution.\n\nFields\n\ndist: joint distribution (typically just a big MvNormal distribution, but maybe a tuple of individual means and covariance matrices)\nds: a tuple with the original dimensionalities of individual Normal distributions\nds[k] = (n,) where n is an integer indicates Multivariate normal of size n\nds[k] = () indicates Univariate normal\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.JointGaussian","page":"Library","title":"ExponentialFamily.JointGaussian","text":"An alias for the JointNormal.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.WishartFast","page":"Library","title":"ExponentialFamily.WishartFast","text":"WishartFast{T <: Real, A <: AbstractMatrix{T}} <: ContinuousMatrixDistribution\n\nThe WishartFast struct represents a fast version of the Wishart distribution. It is similar to the Wishart distribution from Distributions.jl, but it does not check input arguments, allowing the creation of improper Wishart messages.\n\nFor model creation and regular usage, it is recommended to use Wishart from Distributions.jl. The WishartFast distribution is intended for internal purposes and should not be directly used by regular users.\n\nFields\n\nν::T: The degrees of freedom parameter of the Wishart distribution.\ninvS::A: The inverse scale matrix parameter of the Wishart distribution.\n\nNote\n\nInternally, WishartFast stores and creates the inverse of its scale matrix. However, the params() function returns the scale matrix itself for backward compatibility. This is done to ensure better stability in the message passing update rules for ReactiveMP.jl.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.InverseWishartFast","page":"Library","title":"ExponentialFamily.InverseWishartFast","text":"InverseWishartFast{T <: Real, A <: AbstractMatrix{T}} <: ContinuousMatrixDistribution\n\nThe InverseWishartFast struct represents an improper Inverse Wishart distribution. It is similar to the InverseWishart distribution from Distributions.jl, but it does not check input arguments, allowing the creation of improper InverseWishart messages. \n\nFor model creation and regular usage, it is recommended to use InverseWishart from Distributions.jl. The InverseWishartFast distribution is intended for internal purposes and should not be directly used by regular users.\n\nFields\n\nν::T: The degrees of freedom parameter of the inverse Wishart distribution.\nS::A: The scale matrix parameter of the inverse Wishart distribution.\n\nNote\n\nThe InverseWishartFast distribution does not enforce input argument validation, making it suitable for specialized cases where improper message constructions are needed.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.NormalGamma","page":"Library","title":"ExponentialFamily.NormalGamma","text":"NormalGamma{T <: Real} <: ContinuousMultivariateDistribution\n\nA normal-gamma distribution, where T is a real number. This distribution is a joint distribution of a normal random variable with mean μ and precision λ, and a gamma-distributed random variable with shape α and rate β.\n\nFields\n\nμ::T: The mean of the normal distribution.\nλ::T: The precision of the normal distribution.\nα::T: The shape parameter of the gamma distribution.\nβ::T: The rate parameter of the gamma distribution.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.MvNormalWishart","page":"Library","title":"ExponentialFamily.MvNormalWishart","text":"MvNormalWishart{T, M <: AbstractArray{T}, V <: AbstractMatrix{T}, K <: Real, N <: Real} <: ContinuousMatrixDistribution\n\nA multivariate normal-Wishart distribution, where T is the element type of the arrays M and matrices V, and K and N are real numbers. This distribution is a joint distribution of a multivariate normal random variable with mean μ and a Wishart-distributed random matrix with scale matrix Ψ, degrees of freedom ν, and the scalar κ as a scaling parameter.\n\nFields\n\nμ::M: The mean vector of the multivariate normal distribution.\nΨ::V: The scale matrix of the Wishart distribution.\nκ::K: The scaling parameter of the Wishart distribution.\nν::N: The degrees of freedom of the Wishart distribution\n\n\n\n\n\n","category":"type"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#examples-product","page":"Examples","title":"Product of two probability distributions over the same variable","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we'll show you how to use the ExponentialFamily package to calculate the product of probability distributions that both relate to the same variable \"X\".  This operation results in another probability distribution, also centered around the variable \"X\".  It's essential to note that this is distinct from multiplying probability distributions for two different variables, such as \"X\" and \"Y\",  which yields a joint probability distribution. Calculating the product of two probability distributions over the same variable is a crucial step in applying Bayes' rule.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"p(Xvert D) propto underbracep(X)p(DX)_mathrmproductoftwodistributions","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To perform this operation, the ExponentialFamily library employs the prod function. This function takes a product strategy as its first argument. For instance:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using ExponentialFamily, Distributions, BayesBase\n\nprior = Bernoulli(0.5)\nlikelihood = Bernoulli(0.6)\n\nposterior = prod(PreserveTypeProd(Distribution), prior, likelihood)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"You can achieve the same result in the general exponential family form, which operates within the natural parameter space:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nef_prior = convert(ExponentialFamilyDistribution, prior)\nef_likelihood = convert(ExponentialFamilyDistribution, likelihood)\n\nef_posterior = prod(PreserveTypeProd(ExponentialFamilyDistribution), ef_prior, ef_likelihood)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Or even more concisely:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"prod(PreserveTypeProd(ExponentialFamilyDistribution), prior, likelihood)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, multiplying two Bernoulli distributions will always result in another Bernoulli distribution. However, this is not the case for all distributions. For instance, the product of two Laplace distributions may not yield another Laplace distribution, and representing the result in the same form might not be possible. In such cases, it's advisable to calculate the result within the exponential family domain. This is because the product of two exponential family distributions can always be represented as another exponential family distribution, as shown here:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nprior = Laplace(2.0, 3.0)\nlikelihood = Laplace(1.0, 4.0)\n\nprod(PreserveTypeProd(ExponentialFamilyDistribution), prior, likelihood)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that the result does not correspond to the Laplace distribution and returns a generic univariate ExponentialFamilyDistribution. This approach ensures consistency and compatibility, especially when dealing with a wide range of probability distributions. Refer to the BayesBase for the documentation about available product strategies.","category":"page"},{"location":"examples/#Computing-various-useful-attributes-of-an-exponential-family-member","page":"Examples","title":"Computing various useful attributes of an exponential family member","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The package implements attributes of many well known exponential family members, which are defined in this table. The attributes include getbasemeasure, getsufficientstatistics, getlogpartition, getfisherinformation, and others.  In general, the interface for these functions assumes a family member \"tag,\" such as Normal or Bernoulli. Here are some examples of how to use these attributes:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using ExponentialFamily, Distributions\n\n# Returns a function\nbasemeasure_of_normal = getbasemeasure(Normal)\n\nbasemeasure_of_normal(0.0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n# Returns an iterable of functions\nsufficientstatistics_of_gamma = getsufficientstatistics(Gamma)\n\nmap(f -> f(1.0), sufficientstatistics_of_gamma)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Some distributions, like the Laplace distribution, qualify as exponential family members only under certain conditions or when specific information is known in advance. In such cases, the ExponentialFamily package introduces the concept of a conditioner. For instance, the Laplace distribution becomes a member of the exponential family only when the location parameter is known and fixed. Consequently, we condition on the location parameter:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"laplace = Laplace(2.0, 1.0)\n\ncanonical = convert(ExponentialFamilyDistribution, laplace)\n\ngetconditioner(canonical)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# For conditioned distributions, the `conditioner` must be present as a second argument\nbasemeasure_of_laplace = getbasemeasure(Laplace, 2.0)\n\nbasemeasure_of_laplace(1.0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The getlogpartition and getfisherinformation functions optionally accept a space parameter as the first argument. This space parameter specifies the parameterization space, such as MeanParametersSpace or [NaturalParametersSpace]. The result obtained from these functions (in general) depends on the chosen parameter space:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"logpartition_of_gamma_in_mean_space = getlogpartition(MeanParametersSpace(), Gamma)\n\ngamma_parameters_in_mean_space = [ 1.0, 2.0 ]\n\nlogpartition_of_gamma_in_mean_space(gamma_parameters_in_mean_space)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"logparition_of_gamma_in_natural_space = getlogpartition(NaturalParametersSpace(), Gamma)\n\ngamma_parameters_in_natural_space = map(\n    MeanParametersSpace() => NaturalParametersSpace(), \n    Gamma,\n    gamma_parameters_in_mean_space\n)\n\nlogparition_of_gamma_in_natural_space(gamma_parameters_in_natural_space)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The same principle applies to the Fisher information matrix:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"fisherinformation_of_gamma_in_mean_space = getfisherinformation(MeanParametersSpace(), Gamma)\n\nfisherinformation_of_gamma_in_mean_space(gamma_parameters_in_mean_space)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"fisherinformation_of_gamma_in_natural_space = getfisherinformation(NaturalParametersSpace(), Gamma)\n\nfisherinformation_of_gamma_in_natural_space(gamma_parameters_in_natural_space)","category":"page"},{"location":"examples/#Approximating-attributes","page":"Examples","title":"Approximating attributes","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Refer to the ExpectationApproximations.jl package for approximating various attributes of the members of the exponential family.","category":"page"},{"location":"#ExponentialFamily.jl","page":"Home","title":"ExponentialFamily.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia package that extends the functionality of Distributions.jl by providing a collection of exponential family distributions and customized implementations. It is designed to facilitate working with exponential family distributions and offers specialized functionality tailored to this class of distributions.","category":"page"},{"location":"#Core-Principles","page":"Home","title":"Core Principles","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is built around several core principles:","category":"page"},{"location":"","page":"Home","title":"Home","text":"High performance with minimal allocations, striving for complete type stability.\nCompatibility with distributions defined in Distributions.jl.\nEase of use and rich functionality.","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Interface\nExamples\nLibrary","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
