var documenterSearchIndex = {"docs":
[{"location":"interface/#interface","page":"Interface","title":"The ExponentialFamilyDistribution Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"This page describes the philosophy and design concepts behind the ExponentialFamilyDistribution interface. In a nutshell, the primary purpose of the ExponentialFamily package is to provide a generic interface for an ExponentialFamilyDistribution. It is beneficial to become familiar with the Wikipedia article on the exponential family before delving into the implementation details of this package.","category":"page"},{"location":"interface/#Notation","page":"Interface","title":"Notation","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"In the context of the package, exponential family distributions are represented in the form:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"f_X(xmideta) = h(x) cdot expleft eta cdot T(x) - A(eta) right","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Here:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"h(x) is the base measure.\nT(x) represents sufficient statistics.\nA(Œ∑) stands for the log partition.\nŒ∑ denotes the natural parameters.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"In the following discussion we also use the following convention","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Œ∑ corresponds to the distribution's natural parameters in the natural parameter space.\nŒ∏ corresponds to the distribution's mean parameters in the mean parameter space.","category":"page"},{"location":"interface/#ExponentialFamilyDistribution-structure","page":"Interface","title":"ExponentialFamilyDistribution structure","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"ExponentialFamilyDistribution\nExponentialFamilyDistributionAttributes\nlogpdf(ef::ExponentialFamilyDistribution, x)\npdf(ef::ExponentialFamilyDistribution, x)\ncdf(ef::ExponentialFamilyDistribution{D}, x) where {D <: Distribution}\ngetnaturalparameters\ngetattributes\ngetconditioner\nisproper\ngetbasemeasure\ngetsufficientstatistics\ngetlogpartition\ngetfisherinformation\ngetsupport\nbasemeasure\nsufficientstatistics\nlogpartition\nfisherinformation\nisbasemeasureconstant\nConstantBaseMeasure\nNonConstantBaseMeasure","category":"page"},{"location":"interface/#ExponentialFamily.ExponentialFamilyDistribution","page":"Interface","title":"ExponentialFamily.ExponentialFamilyDistribution","text":"ExponentialFamilyDistribution(::Type{T}, naturalparameters, conditioner, attributes)\n\nExponentialFamilyDistribution structure represents a generic exponential family distribution in natural parameterization. Type T can be either a distribution type (e.g. from the Distributions.jl package) or a variate type (e.g. Univariate).\n\ngetattributes returns either nothing or ExponentialFamilyDistributionAttributes.\ngetbasemeasure returns a positive a valued function. \ngetsufficientstatistics returns an iterable of functions such as [x, x^2] or [x, logx].\ngetnaturalparameters returns an iterable holding the values of the natural parameters. \ngetlogpartition return a function that depends on the naturalparameters and it ensures that the distribution is normalized to 1. \ngetsupport returns the set that the distribution is defined over. Could be real numbers, positive integers, 3d cube etc. Use ither the ‚àà operator or the insupport() function to check if a value belongs to the support.\n\nnote: Note\nThe attributes can be nothing. In which case the package will try to derive the corresponding attributes from the type T.\n\nSee also: getbasemeasure, getsufficientstatistics, getnaturalparameters, getlogpartition, getsupport\n\n\n\n\n\n","category":"type"},{"location":"interface/#ExponentialFamily.ExponentialFamilyDistributionAttributes","page":"Interface","title":"ExponentialFamily.ExponentialFamilyDistributionAttributes","text":"ExponentialFamilyDistributionAttributes(basemeasure, sufficientstatistics, logpartition, support)\n\nA structure to represent the attributes of an exponential family member.\n\nFields\n\nbasemeasure::B: The basemeasure of the exponential family member.\nsufficientstatistics::S: The sufficient statistics of the exponential family member.\nlogpartition::L: The log-partition (cumulant) of the exponential family member.\nsupport::P: The support of the exponential family member.\n\nSee also: ExponentialFamilyDistribution\n\n\n\n\n\n","category":"type"},{"location":"interface/#Distributions.logpdf-Tuple{ExponentialFamilyDistribution, Any}","page":"Interface","title":"Distributions.logpdf","text":"logpdf(ef::ExponentialFamilyDistribution, x)\n\nEvaluates and returns the log-density of the exponential family distribution for the input x.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Distributions.pdf-Tuple{ExponentialFamilyDistribution, Any}","page":"Interface","title":"Distributions.pdf","text":"pdf(ef::ExponentialFamilyDistribution, x)\n\nEvaluates and returns the probability density function of the exponential family distribution for the input x.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Distributions.cdf-Union{Tuple{D}, Tuple{ExponentialFamilyDistribution{D}, Any}} where D<:Distribution","page":"Interface","title":"Distributions.cdf","text":"cdf(ef::ExponentialFamilyDistribution{D}, x) where { D <: Distribution }\n\nEvaluates and returns the cumulative distribution function of the exponential family distribution for the input x.\n\n\n\n\n\n","category":"method"},{"location":"interface/#ExponentialFamily.getnaturalparameters","page":"Interface","title":"ExponentialFamily.getnaturalparameters","text":"getnaturalparameters(::ExponentialFamilyDistribution)\n\nGet the natural parameters of the exponential family distribution.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.getattributes","page":"Interface","title":"ExponentialFamily.getattributes","text":"getattributes(::ExponentialFamilyDistribution)\n\nReturns iether the attributes of the exponential family member or nothing. \n\nSee also: ExponentialFamilyDistributionAttributes\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.getconditioner","page":"Interface","title":"ExponentialFamily.getconditioner","text":"getconditioner(::ExponentialFamilyDistribution)\n\nReturns either the conditioner of the exponential family distribution or nothing. conditioner is a fixed parameter that is used to ensure that the distribution belongs to the exponential family.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.isproper","page":"Interface","title":"ExponentialFamily.isproper","text":"isproper(::ExponentialFamilyDistribution)\n\nChecks if the object of type ExponentialFamilyDistribution is a proper distribution.\n\n\n\n\n\nisproper([ space = NaturalParametersSpace() ], ::Type{T}, parameters, conditioner = nothing) where { T <: Distribution }\n\nA specific verion of isproper defined particularly for distribution types from Distributions.jl package. Does not require an instance of the ExponentialFamilyDistribution and can be called directly with a specific distribution type instead. Optionally, accepts the space parameter, which defines the parameters space. For conditional exponential family distributions requires an extra conditioner argument.\n\nSee also: NaturalParametersSpace, MeanParametersSpace\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.getbasemeasure","page":"Interface","title":"ExponentialFamily.getbasemeasure","text":"getbasemeasure(::ExponentialFamilyDistribution)\ngetbasemeasure(::Type{ <: Distribution }, [ conditioner ])\n\nReturns the base measure function of the exponential family distribution.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.getsufficientstatistics","page":"Interface","title":"ExponentialFamily.getsufficientstatistics","text":"getsufficientstatistics(::ExponentialFamilyDistribution)\ngetsufficientstatistics(::Type{ <: Distribution }, [ conditioner ])\n\nReturns the list of sufficient statistics of the exponential family distribution.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.getlogpartition","page":"Interface","title":"ExponentialFamily.getlogpartition","text":"getlogpartition(::ExponentialFamilyDistribution)\ngetlogpartition([ space ], ::Type{ <: Distribution }, [ conditioner ])\n\nReturns the log partition function of the exponential family distribution.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.getfisherinformation","page":"Interface","title":"ExponentialFamily.getfisherinformation","text":"getfisherinformation(::ExponentialFamilyDistribution)\ngetfisherinformation([ space ], ::Type{ <: Distribution }, [ conditioner ])\n\nReturns the function that computes the fisher information matrix of the exponential family distribution.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.getsupport","page":"Interface","title":"ExponentialFamily.getsupport","text":"getsupport(distribution_or_type)\n\nReturns the support of the exponential family distribution.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.basemeasure","page":"Interface","title":"ExponentialFamily.basemeasure","text":"basemeasure(::ExponentialFamilyDistribution, x)\n\nReturns the computed value of basemeasure of the exponential family distribution at the point x.\n\nSee also: getbasemeasure\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.sufficientstatistics","page":"Interface","title":"ExponentialFamily.sufficientstatistics","text":"sufficientstatistics(::ExponentialFamilyDistribution)\n\nReturns the computed values of sufficientstatistics of the exponential family distribution at the point x.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.logpartition","page":"Interface","title":"ExponentialFamily.logpartition","text":"logpartition(::ExponentialFamilyDistribution, Œ∑)\n\nReturn the computed value of logpartition of the exponential family distribution at the point Œ∑. By default Œ∑ = getnaturalparameters(ef).\n\nSee also: getlogpartition\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.fisherinformation","page":"Interface","title":"ExponentialFamily.fisherinformation","text":"fisherinformation(distribution, Œ∑)\n\nReturn the computed value of fisherinformation of the exponential family distribution at the point Œ∑ By default Œ∑ = getnaturalparameters(ef).\n\nSee also: getfisherinformation\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.isbasemeasureconstant","page":"Interface","title":"ExponentialFamily.isbasemeasureconstant","text":"isbasemeasureconstant(something)\n\nReturns either NonConstantBaseMeasure() or ConstantBaseMeasure() depending on if the base measure is a constant with respect to the natural parameters of something or not. By default the package assumes that any base measure in a form of the Function is not a constant. It, however, is not true for basemeasure that simply return a constant. In such cases the isbasemeasureconstant must have a specific method.\n\nSee also: getbasemeasure, basemeasure\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.ConstantBaseMeasure","page":"Interface","title":"ExponentialFamily.ConstantBaseMeasure","text":"A trait object representing that the base measure is constant.\n\n\n\n\n\n","category":"type"},{"location":"interface/#ExponentialFamily.NonConstantBaseMeasure","page":"Interface","title":"ExponentialFamily.NonConstantBaseMeasure","text":"A trait object representing that the base measure is not constant.\n\n\n\n\n\n","category":"type"},{"location":"interface/#Interfacing-with-Distributions-Defined-in-the-Distributions.jl-Package","page":"Interface","title":"Interfacing with Distributions Defined in the Distributions.jl Package","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The Distributions.jl package is a comprehensive library that defines a wide collection of standard distributions. The main objective of the Distributions package is to offer a unified interface for evaluating likelihoods of various distributions, along with convenient sampling routines from these distributions. The ExponentialFamily package provides a lightweight interface for a subset of the distributions defined in the Distributions package.","category":"page"},{"location":"interface/#Conversion-between-Mean-Parameters-Space-and-Natural-Parameters-Space","page":"Interface","title":"Conversion between Mean Parameters Space and Natural Parameters Space","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The Distributions package introduces the params function, which allows the retrieval of parameters for different distributions. For example:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"using Distributions, ExponentialFamily\n\ndistribution = Bernoulli(0.25)\n\ntuple_of_Œ∏ = params(distribution)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"These parameters are typically defined in what's known as the mean parameters space. However, the ExponentialFamilyDistribution expects parameters to be in the natural parameters space. To facilitate conversion between these two representations, the ExponentialFamily package provides two structures:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"MeanToNatural\nNaturalToMean\nExponentialFamily.getmapping","category":"page"},{"location":"interface/#ExponentialFamily.MeanToNatural","page":"Interface","title":"ExponentialFamily.MeanToNatural","text":"MeanToNatural(::Type{T})\n\nReturn the transformation function that maps the parameters in the mean parameters space to the natural parameters space for a distribution of type T. The transformation function is of signature (params_in_mean_space, [ conditioner ]) -> params_in_natural_space.\n\nSee also: NaturalToMean\n\n\n\n\n\n","category":"type"},{"location":"interface/#ExponentialFamily.NaturalToMean","page":"Interface","title":"ExponentialFamily.NaturalToMean","text":"NaturalToMean(::Type{T})\n\nReturn the transformation function that maps the parameters in the natural parameters space to the mean parameters space for a distribution of type T. The transformation function is of signature (params_in_natural_space, [ conditioner ]) -> params_in_mean_space.\n\nSee also: MeanToNatural\n\n\n\n\n\n","category":"type"},{"location":"interface/#ExponentialFamily.getmapping","page":"Interface","title":"ExponentialFamily.getmapping","text":"getmapping(::Pair{L, R}, T)\n\nReturns a transformation L -> R between different parametrizations of a distribution of type T.\n\nSee also: NaturalParametersSpace, MeanParametersSpace, NaturalToMean, MeanToNatural\n\n\n\n\n\n","category":"function"},{"location":"interface/","page":"Interface","title":"Interface","text":"To convert from the mean parameters space to the corresponding natural parameters space, you can use the following code:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"tuple_of_Œ∑ = MeanToNatural(Bernoulli)(tuple_of_Œ∏)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"And to convert back:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"tuple_of_Œ∏ = NaturalToMean(Bernoulli)(tuple_of_Œ∑)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Alternatuvely, the following API is supported ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"map(MeanParametersSpace() => NaturalParametersSpace(), Bernoulli, tuple_of_Œ∏)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"map(NaturalParametersSpace() => MeanParametersSpace(), Bernoulli, tuple_of_Œ∑)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"While the ExponentialFamily package employs the respective mappings where needed, it's also possible to call these functions manually. For instance, the generic implementation of the convert function between ExponentialFamilyDistribution and Distribution is built in terms of MeanToNatural and NaturalToMean. Moreover, the convert function performs checks to ensure that the provided parameters and conditioner are suitable for a specific distribution type.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"isproper(::Type{T}, parameters, conditioner = nothing) where { T <: Distribution }","category":"page"},{"location":"interface/#ExponentialFamily.isproper-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Any}} where T<:Distribution","page":"Interface","title":"ExponentialFamily.isproper","text":"isproper([ space = NaturalParametersSpace() ], ::Type{T}, parameters, conditioner = nothing) where { T <: Distribution }\n\nA specific verion of isproper defined particularly for distribution types from Distributions.jl package. Does not require an instance of the ExponentialFamilyDistribution and can be called directly with a specific distribution type instead. Optionally, accepts the space parameter, which defines the parameters space. For conditional exponential family distributions requires an extra conditioner argument.\n\nSee also: NaturalParametersSpace, MeanParametersSpace\n\n\n\n\n\n","category":"method"},{"location":"interface/#Note-on-the-conditioned-distributions","page":"Interface","title":"Note on the conditioned distributions","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"For the conditioned distributions, two additional functions separate_conditioner and join_conditioner are used to separate the conditioner and actual parameters returned from the Distributions.params function.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"ExponentialFamily.separate_conditioner\nExponentialFamily.join_conditioner","category":"page"},{"location":"interface/#ExponentialFamily.separate_conditioner","page":"Interface","title":"ExponentialFamily.separate_conditioner","text":"separate_conditioner(::Type{T}, params) where {T <: Distribution}\n\nSeparates the conditioner argument from params and returns a tuple of (conditioned_params, conditioner). By default returns (params, nothing) but can be overwritten for certain distributions.\n\njulia> (cparams, conditioner) = ExponentialFamily.separate_conditioner(Laplace, (0.0, 1.0))\n((1.0,), 0.0)\n\njulia> params = ExponentialFamily.join_conditioner(Laplace, cparams, conditioner)\n(0.0, 1.0)\n\njulia> Laplace(params...) == Laplace(0.0, 1.0)\ntrue\n\nSee also: ExponentialFamily.join_conditioner\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.join_conditioner","page":"Interface","title":"ExponentialFamily.join_conditioner","text":"join_conditioner(::Type{T}, params, conditioner) where { T <: Distribution }\n\nJoins the conditioner argument with the params and returns a tuple of joined params, such that it can be used in a constructor of the T distribution.\n\njulia> (cparams, conditioner) = ExponentialFamily.separate_conditioner(Laplace, (0.0, 1.0))\n((1.0,), 0.0)\n\njulia> params = ExponentialFamily.join_conditioner(Laplace, cparams, conditioner)\n(0.0, 1.0)\n\njulia> Laplace(params...) == Laplace(0.0, 1.0)\ntrue\n\nSee also: ExponentialFamily.separate_conditioner\n\n\n\n\n\n","category":"function"},{"location":"interface/","page":"Interface","title":"Interface","text":"For example, Laplace distribution defines the functions in the following way","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"# `params` are coming from the `Distribution.params(::Laplace)` and return (location, scale)\n# The `location`, however is a fixed parameter in the exponential distribution representation of Laplace\n# Hence, we return a tuple of tuple of actual parameter and the conditioner\nfunction separate_conditioner(::Type{Laplace}, params)\n    location, scale = params\n    return ((scale, ), location)\nend\n\n# The `join_conditioner` must join the actual parameters and the conditioner in such a way, that it is compatible \n# with the `Laplace` structure from the `Distributions.jl`. In Laplace, the location parameter goes first.\nfunction join_conditioner(::Type{Laplace}, cparams, conditioner) \n    (scale, ) = cparams\n    location = conditioner\n    return (location, scale)\nend","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"In general, all functions defined for the ExponentialFamilyDistribution, such as getlogpartition or getbasemeasure accept an optional conditioner parameter, which is assumed to be nothing.  Conditioned distribution implement the \"conditioned\" versions of such functions by explicitly requiring the conditioner parameter, e.g.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"getsufficientstatistics(Laplace, 1.0) # explicit `conditioner = 1.0`","category":"page"},{"location":"interface/#Efficient-packing-of-the-natural-parameters-into-a-vectorized-form","page":"Interface","title":"Efficient packing of the natural parameters into a vectorized form","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The ExponentialFamilyDistribution type stores its natural parameters in a vectorized, or packed, format. This is done for the sake of efficiency and to enhance compatibility with autodiff packages like ForwardDiff, which anticipate a single parameter vector. As a result, the tuple of natural parameters needs to be converted to its corresponding vectorized form and vice versa. To achieve this, the package provides the flatten_parameters, pack_parameters and unpack_parameters functions.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"ExponentialFamily.flatten_parameters\nExponentialFamily.pack_parameters\nExponentialFamily.unpack_parameters","category":"page"},{"location":"interface/#ExponentialFamily.flatten_parameters","page":"Interface","title":"ExponentialFamily.flatten_parameters","text":"flatten_parameters(::Type{T}, params::Tuple)\n\nThis function returns the parameters of a distribution of type T in a flattened form without actually allocating the container.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.pack_parameters","page":"Interface","title":"ExponentialFamily.pack_parameters","text":"pack_parameters([ space ], ::Type{T}, params::Tuple)\n\nThis function returns the parameters of a distribution of type T in a vectorized (packed) form. For most of the distributions the packed versions are of the  same structure in any parameters space. For some distributions, however, it is necessary to indicate the space of the packaged parameters.\n\n\n\n\n\n","category":"function"},{"location":"interface/#ExponentialFamily.unpack_parameters","page":"Interface","title":"ExponentialFamily.unpack_parameters","text":"unpack_parameters([ space ], ::Type{T}, parameters)\n\nThis function \"unpack\" the vectorized form of the parameters in a tuple. For most of the distributions the packed parameters are of the  same structure in any parameters space. For some distributions, however, it is necessary to indicate the space of the packaged parameters.\n\nSee also: MeanParametersSpace, NaturalParametersSpace\n\n\n\n\n\n","category":"function"},{"location":"interface/","page":"Interface","title":"Interface","text":"These functions are not exported by default, but it's important to note that the ExponentialFamilyDistributions type doesn't actually store the parameter tuple internally. Instead, the getnaturalparameters function returns the corresponding vectorized (packed) form of the natural parameters. In general, only the ExponentialFamily.unpack_parameters function must be implemented, as others could be implemented in a generic way.","category":"page"},{"location":"interface/#Attributes-of-the-exponential-family-distribution-based-on-Distribution","page":"Interface","title":"Attributes of the exponential family distribution based on Distribution","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The ExponentialFamilyDistribution{T} where { T <: Distribution } type encompasses all fundamental attributes of the exponential family, including basemeasure, logpartition, sufficientstatistics, and fisherinformation. Furthermore, it's possible to retrieve the actual functions that compute these attributes. For instance, consider the following example:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"basemeasure_of_bernoilli = getbasemeasure(Bernoulli)\n\nbasemeasure_of_bernoilli(0)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"isproper(::Type{T}, parameters, conditioner) where {T <: Distribution}\ngetbasemeasure(::Type{T}, ::Nothing) where {T <: Distribution}\ngetsufficientstatistics(::Type{T}, ::Nothing) where { T <: Distribution }\ngetlogpartition(::Type{T}, _) where { T <: Distribution }\ngetfisherinformation(::Type{T}, _) where { T <: Distribution }","category":"page"},{"location":"interface/#ExponentialFamily.isproper-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T<:Distribution","page":"Interface","title":"ExponentialFamily.isproper","text":"isproper([ space = NaturalParametersSpace() ], ::Type{T}, parameters, conditioner = nothing) where { T <: Distribution }\n\nA specific verion of isproper defined particularly for distribution types from Distributions.jl package. Does not require an instance of the ExponentialFamilyDistribution and can be called directly with a specific distribution type instead. Optionally, accepts the space parameter, which defines the parameters space. For conditional exponential family distributions requires an extra conditioner argument.\n\nSee also: NaturalParametersSpace, MeanParametersSpace\n\n\n\n\n\n","category":"method"},{"location":"interface/#ExponentialFamily.getbasemeasure-Union{Tuple{T}, Tuple{Type{T}, Nothing}} where T<:Distribution","page":"Interface","title":"ExponentialFamily.getbasemeasure","text":"getbasemeasure(::Type{<:Distribution}, [ conditioner ])\n\nA specific verion of getbasemeasure defined particularly for distribution types from Distributions.jl package. Does not require an instance of the ExponentialFamilyDistribution and can be called directly with a specific distribution type instead. For conditional exponential family distributions requires an extra conditioner argument.\n\n\n\n\n\n","category":"method"},{"location":"interface/#ExponentialFamily.getsufficientstatistics-Union{Tuple{T}, Tuple{Type{T}, Nothing}} where T<:Distribution","page":"Interface","title":"ExponentialFamily.getsufficientstatistics","text":"getsufficientstatistics(::Type{<:Distribution}, [ conditioner ])\n\nA specific verion of getsufficientstatistics defined particularly for distribution types from Distributions.jl package. Does not require an instance of the ExponentialFamilyDistribution and can be called directly with a specific distribution type instead. For conditional exponential family distributions requires an extra conditioner argument.\n\n\n\n\n\n","category":"method"},{"location":"interface/#ExponentialFamily.getlogpartition-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Distribution","page":"Interface","title":"ExponentialFamily.getlogpartition","text":"getlogpartition([ space = NaturalParametersSpace() ], ::Type{T}, [ conditioner ]) where { T <: Distribution }\n\nA specific verion of getlogpartition defined particularly for distribution types from Distributions.jl package. Does not require an instance of the ExponentialFamilyDistribution and can be called directly with a specific distribution type instead. Optionally, accepts the space parameter, which defines the parameters space. For conditional exponential family distributions requires an extra conditioner argument.\n\nSee also: NaturalParametersSpace, MeanParametersSpace\n\n\n\n\n\n","category":"method"},{"location":"interface/#ExponentialFamily.getfisherinformation-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Distribution","page":"Interface","title":"ExponentialFamily.getfisherinformation","text":"getfisherinformation([ space = NaturalParametersSpace() ], ::Type{T}) where { T <: Distribution }\n\nA specific verion of getfisherinformation defined particularly for distribution types from Distributions.jl package. Does not require an instance of the ExponentialFamilyDistribution and can be called directly with a specific distribution type instead. Optionally, accepts the space parameter, which defines the parameters space. For conditional exponential family distributions requires an extra conditioner argument.\n\nSee also: NaturalParametersSpace, MeanParametersSpace\n\n\n\n\n\n","category":"method"},{"location":"interface/","page":"Interface","title":"Interface","text":"Certain functions require knowledge about which parameter space is being used. By default, the NaturalParametersSpace is assumed.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"getlogpartition(Bernoulli) === getlogpartition(NaturalParametersSpace(), Bernoulli)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"NaturalParametersSpace\nMeanParametersSpace","category":"page"},{"location":"interface/#ExponentialFamily.NaturalParametersSpace","page":"Interface","title":"ExponentialFamily.NaturalParametersSpace","text":"NaturalParametersSpace\n\nSpecifies the natural parameters space Œ∑ as the desired parameters space. Some functions (such as logpartition or fisherinformation) accept an additional space parameter to disambiguate the desired parameters space.  Use map(NaturalParametersSpace() => MeanParametersSpace(), T, parameters, conditioner) to map the parameters and the conditioner of a distribution of type T from the natural parametrization to the corresponding mean parametrization.\n\nSee also: MeanParametersSpace\n\n\n\n\n\n","category":"type"},{"location":"interface/#ExponentialFamily.MeanParametersSpace","page":"Interface","title":"ExponentialFamily.MeanParametersSpace","text":"MeanParametersSpace\n\nSpecifies the mean parameters space Œ∏ as the desired parameters space. Some functions (such as logpartition or fisherinformation) accept an additional space parameter to disambiguate the desired parameters space.  Use map(MeanParametersSpace() => NaturalParametersSpace(), T, parameters, conditioner) to map the parameters and the conditioner of a distribution of type T from the mean parametrization to the corresponding natural parametrization.\n\nSee also: NaturalParametersSpace\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"Interface","title":"Interface","text":"The isbasemeasureconstant function is defined for all supported distributions as well.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"isbasemeasureconstant(Bernoulli)","category":"page"},{"location":"interface/#Extra-defined-distributions","page":"Interface","title":"Extra defined distributions","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The package defines a list of extra distributions for a purpose of more efficiency in different circumstances. The list is available here.","category":"page"},{"location":"library/#library","page":"Library","title":"Library API","text":"","category":"section"},{"location":"library/#library-prod","page":"Library","title":"Product API","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"One of the central functions in this package is the ability to calculate the product of two distributions over the same variable.  You can also refer to the corresponding example for practical usage.","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"The prod function is a key feature of this package.  It accepts a strategy as its first argument, which defines how the prod function should behave and what results you can expect.","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"prod(::ClosedProd, left, right)\nExponentialFamily.default_prod_rule","category":"page"},{"location":"library/#Base.prod-Tuple{ClosedProd, Any, Any}","page":"Library","title":"Base.prod","text":"prod(strategy, left, right)\n\nprod function is used to find a product of two probability distributions (or any other objects) over same variable (e.g. ùìù(x|Œº1, œÉ1) √ó ùìù(x|Œº2, œÉ2)). There are multiple strategies for prod function, e.g. ClosedProd, GenericProd or PreserveTypeProd.\n\nExamples:\n\nusing ExponentialFamily\n\nproduct = prod(ClosedProd(), NormalMeanVariance(-1.0, 1.0), NormalMeanVariance(1.0, 1.0))\n\nmean(product), var(product)\n\n# output\n(0.0, 0.5)\n\nSee also: default_prod_rule, ClosedProd, PreserveTypeProd, GenericProd\n\n\n\n\n\n","category":"method"},{"location":"library/#ExponentialFamily.default_prod_rule","page":"Library","title":"ExponentialFamily.default_prod_rule","text":"default_prod_rule(::Type, ::Type)\n\nReturns the most suitable prod rule for two given distribution types. Returns UnspecifiedProd by default.\n\nSee also: prod, ClosedProd, GenericProd\n\n\n\n\n\n","category":"function"},{"location":"library/#library-prod-strategies","page":"Library","title":"Product strategies","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"For certain distributions, it's possible to compute the product using a straightforward mathematical equation, yielding a closed-form solution.  However, for some distributions, finding a closed-form solution might not be feasible.  Various strategies ensure consistent behavior in these situations.  These strategies can either guarantee a fast and closed-form solution or, when necessary, fall back to a slower but more generic method.","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"ExponentialFamily.UnspecifiedProd\nExponentialFamily.ClosedProd\nExponentialFamily.PreserveTypeProd\nExponentialFamily.PreserveTypeLeftProd\nExponentialFamily.PreserveTypeRightProd\nExponentialFamily.GenericProd\nExponentialFamily.ProductOf\nExponentialFamily.LinearizedProductOf","category":"page"},{"location":"library/#ExponentialFamily.UnspecifiedProd","page":"Library","title":"ExponentialFamily.UnspecifiedProd","text":"UnspecifiedProd\n\nA strategy for the prod function, which does not compute the prod, but instead fails in run-time and prints a descriptive error message.\n\nSee also: prod, ClosedProd, GenericProd\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.ClosedProd","page":"Library","title":"ExponentialFamily.ClosedProd","text":"ClosedProd\n\nClosedProd is one of the strategies for prod function. This strategy uses either PreserveTypeProd(Distribution) or PreserveTypeProd(ExponentialFamilyDistribution),      depending on the types of the input arguments. For example, if both inputs are of type Distribution, then ClosedProd would fallback to PreserveTypeProd(Distribution).\n\nSee also: prod, PreserveTypeProd, GenericProd\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.PreserveTypeProd","page":"Library","title":"ExponentialFamily.PreserveTypeProd","text":"PreserveTypeProd{T}\n\nPreserveTypeProd is one of the strategies for prod function. This strategy constraint an output of a prod to be in some specific form. By default it uses the strategy from default_prod_rule and converts the output to the prespecified type but can be overwritten  for some distributions for better performance.\n\nSee also: prod, ClosedProd, PreserveTypeLeftProd, PreserveTypeRightProd, GenericProd\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.PreserveTypeLeftProd","page":"Library","title":"ExponentialFamily.PreserveTypeLeftProd","text":"PreserveTypeLeftProd\n\nAn alias for the PreserveTypeProd(L) where L is the type of the left argument of the prod function.\n\nSee also: prod, PreserveTypeProd, PreserveTypeRightProd, GenericProd\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.PreserveTypeRightProd","page":"Library","title":"ExponentialFamily.PreserveTypeRightProd","text":"PreserveTypeRightProd\n\nAn alias for the PreserveTypeProd(R) where R is the type of the right argument of the prod function.    \n\nSee also: prod, PreserveTypeProd, PreserveTypeLeftProd, GenericProd\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.GenericProd","page":"Library","title":"ExponentialFamily.GenericProd","text":"GenericProd\n\nGenericProd is one of the strategies for prod function. This strategy does always produces a result,  even if the closed form product is not availble, in which case simply returns the ProductOf object. GenericProd sometimes  fallbacks to the default_prod_rule which it may or may not use under some circumstances.  For example if the default_prod_rule is ClosedProd - GenericProd will try to optimize the tree with  analytical closed solutions (if possible).\n\nSee also: prod, ProductOf, ClosedProd, PreserveTypeProd, default_prod_rule\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.ProductOf","page":"Library","title":"ExponentialFamily.ProductOf","text":"ProductOf\n\nA generic structure representing a product of two distributions.  Can be viewed as a tuple of (left, right).  Does not check nor supports neither variate forms during the creation stage. Uses the fuse_support function to fuse supports of two different distributions.\n\nThis object does not define any statistical properties (such as mean or var etc) and cannot be used as a distribution explicitly. Instead, it must be further approximated as a member of some other distribution. \n\nSee also: prod, GenericProd, ExponentialFamily.fuse_supports\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.LinearizedProductOf","page":"Library","title":"ExponentialFamily.LinearizedProductOf","text":"LinearizedProductOf\n\nAn efficient linearized implementation of product of multiple distributions. This structure prevents ProductOf tree from growing too much in case of identical objects.  This trick significantly reduces Julia compilation times when closed product rules are not available but distributions are of the same type. Essentially this structure linearizes leaves of the ProductOf tree in case if it sees objects of the same type (via dispatch).\n\nSee also: ProductOf, [GenericProd]\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"These strategies offer flexibility and reliability when working with different types of distributions, ensuring that the package can handle a wide range of cases effectively.","category":"page"},{"location":"library/#library-list-distributions-extra","page":"Library","title":"Additional distributions","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"These are the distributions that are not included in the Distributions.jl package.","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"ExponentialFamily.MatrixDirichlet\nExponentialFamily.GammaShapeRate\nExponentialFamily.GammaShapeScale\nExponentialFamily.NormalMeanPrecision\nExponentialFamily.NormalMeanVariance\nExponentialFamily.NormalWeightedMeanPrecision\nExponentialFamily.MvNormalMeanPrecision\nExponentialFamily.MvNormalMeanCovariance\nExponentialFamily.MvNormalWeightedMeanPrecision\nExponentialFamily.JointNormal\nExponentialFamily.WishartFast\nExponentialFamily.InverseWishartFast\nExponentialFamily.JointGaussian\nExponentialFamily.NormalGamma\nExponentialFamily.MvNormalWishart\nExponentialFamily.FactorizedJoint","category":"page"},{"location":"library/#ExponentialFamily.MatrixDirichlet","page":"Library","title":"ExponentialFamily.MatrixDirichlet","text":"MatrixDirichlet{T <: Real, A <: AbstractMatrix{T}} <: ContinuousMatrixDistribution\n\nA matrix-valued MatrixDirichlet distribution, where T is the element type of the matrix A. The a field stores the matrix parameter of the distribution.\n\nFields\n\na::A: The matrix parameter of the MatrixDirichlet distribution.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.GammaShapeRate","page":"Library","title":"ExponentialFamily.GammaShapeRate","text":"GammaShapeRate{T <: Real}\n\nA univariate gamma distribution parametrized by its shape a and rate b.\n\nFields\n\na: The shape parameter of the gamma distribution. It should be a positive real number.\nb: The rate parameter of the gamma distribution. It should be a positive real number.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.GammaShapeScale","page":"Library","title":"ExponentialFamily.GammaShapeScale","text":"GammaShapeScale{T}\n\nA continuous univariate gamma distribution parametrized by its shape Œ± and scale Œ≤ parameters.\n\nFields\n\nŒ±: The shape parameter of the gamma distribution. It should be a positive real number.\nŒ≤: The scale parameter of the gamma distribution. It should be a positive real number.\n\nNote\n\nGammaShapeScale is an alias for Gamma from Distributions.jl.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.NormalMeanPrecision","page":"Library","title":"ExponentialFamily.NormalMeanPrecision","text":"NormalMeanPrecision{T <: Real} <: ContinuousUnivariateDistribution\n\nA normal distribution with a known mean Œº and precision w.\n\nFields\n\nŒº::T: The mean of the normal distribution.\nw::T: The precision of the normal distribution.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.NormalMeanVariance","page":"Library","title":"ExponentialFamily.NormalMeanVariance","text":"NormalMeanVariance{T <: Real} <: ContinuousUnivariateDistribution\n\nA normal distribution with a known mean Œº and variance v.\n\nFields\n\nŒº::T: The mean of the normal distribution.\nv::T: The variance of the normal distribution.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.NormalWeightedMeanPrecision","page":"Library","title":"ExponentialFamily.NormalWeightedMeanPrecision","text":"NormalWeightedMeanPrecision{T <: Real} <: ContinuousUnivariateDistribution\n\nA normal distribution parametrized by its natural parameters: the weighted mean xi and precision w.\n\nFields\n\nxi::T: The weighted mean of the normal distribution. xi is computed as w * Œº, where Œº is the mean of the distribution.\nw::T: The precision (inverse variance) of the normal distribution.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.MvNormalMeanPrecision","page":"Library","title":"ExponentialFamily.MvNormalMeanPrecision","text":"MvNormalMeanPrecision{T <: Real, M <: AbstractVector{T}, P <: AbstractMatrix{T}} <: AbstractMvNormal\n\nA multivariate normal distribution with mean Œº and precision matrix Œõ, where T is the element type of the vectors M and matrices P.\n\nFields\n\nŒº::M: The mean vector of the multivariate normal distribution.\nŒõ::P: The precision matrix (inverse of the covariance matrix) of the multivariate normal distribution.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.MvNormalMeanCovariance","page":"Library","title":"ExponentialFamily.MvNormalMeanCovariance","text":"MvNormalMeanCovariance{T <: Real, M <: AbstractVector{T}, P <: AbstractMatrix{T}} <: AbstractMvNormal\n\nA multivariate normal distribution with mean Œº and covariance matrix Œ£, where T is the element type of the vectors M and matrices P.\n\nFields\n\nŒº::M: The mean vector of the multivariate normal distribution.\nŒ£::P: The covariance matrix of the multivariate normal distribution\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.MvNormalWeightedMeanPrecision","page":"Library","title":"ExponentialFamily.MvNormalWeightedMeanPrecision","text":"MvNormalWeightedMeanPrecision{T <: Real, M <: AbstractVector{T}, P <: AbstractMatrix{T}} <: AbstractMvNormal\n\nA multivariate normal distribution with a weighted mean vector xi and precision matrix Œõ, where T is the element type of the vectors M and matrices P. This struct represents a natural parametrization of a multivariate Gaussian distribution.\n\nFields\n\nxi::M: The weighted mean vector of the multivariate normal distribution.\nŒõ::P: The precision matrix (inverse of the covariance matrix) of the multivariate normal distribution.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.JointNormal","page":"Library","title":"ExponentialFamily.JointNormal","text":"JointNormal{D, S}\n\nJointNormal is an auxilary structure used for the joint marginal over Normally distributed variables. JointNormal stores a vector with the original dimensionalities (ds), so statistics can later be re-separated.\n\nUse ExponentialFamily.getcomponent(joint, index) to get a specific component of the joint distribution.\n\nFields\n\ndist: joint distribution (typically just a big MvNormal distribution, but maybe a tuple of individual means and covariance matrices)\nds: a tuple with the original dimensionalities of individual Normal distributions\nds[k] = (n,) where n is an integer indicates Multivariate normal of size n\nds[k] = () indicates Univariate normal\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.WishartFast","page":"Library","title":"ExponentialFamily.WishartFast","text":"WishartFast{T <: Real, A <: AbstractMatrix{T}} <: ContinuousMatrixDistribution\n\nThe WishartFast struct represents a fast version of the Wishart distribution. It is similar to the Wishart distribution from Distributions.jl, but it does not check input arguments, allowing the creation of improper Wishart messages.\n\nFor model creation and regular usage, it is recommended to use Wishart from Distributions.jl. The WishartFast distribution is intended for internal purposes and should not be directly used by regular users.\n\nFields\n\nŒΩ::T: The degrees of freedom parameter of the Wishart distribution.\ninvS::A: The inverse scale matrix parameter of the Wishart distribution.\n\nNote\n\nInternally, WishartFast stores and creates the inverse of its scale matrix. However, the params() function returns the scale matrix itself for backward compatibility. This is done to ensure better stability in the message passing update rules for ReactiveMP.jl.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.InverseWishartFast","page":"Library","title":"ExponentialFamily.InverseWishartFast","text":"InverseWishartFast{T <: Real, A <: AbstractMatrix{T}} <: ContinuousMatrixDistribution\n\nThe InverseWishartFast struct represents an improper Inverse Wishart distribution. It is similar to the InverseWishart distribution from Distributions.jl, but it does not check input arguments, allowing the creation of improper InverseWishart messages. \n\nFor model creation and regular usage, it is recommended to use InverseWishart from Distributions.jl. The InverseWishartFast distribution is intended for internal purposes and should not be directly used by regular users.\n\nFields\n\nŒΩ::T: The degrees of freedom parameter of the inverse Wishart distribution.\nS::A: The scale matrix parameter of the inverse Wishart distribution.\n\nNote\n\nThe InverseWishartFast distribution does not enforce input argument validation, making it suitable for specialized cases where improper message constructions are needed.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.JointGaussian","page":"Library","title":"ExponentialFamily.JointGaussian","text":"An alias for the JointNormal.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.NormalGamma","page":"Library","title":"ExponentialFamily.NormalGamma","text":"NormalGamma{T <: Real} <: ContinuousMultivariateDistribution\n\nA normal-gamma distribution, where T is a real number. This distribution is a joint distribution of a normal random variable with mean Œº and precision Œª, and a gamma-distributed random variable with shape Œ± and rate Œ≤.\n\nFields\n\nŒº::T: The mean of the normal distribution.\nŒª::T: The precision of the normal distribution.\nŒ±::T: The shape parameter of the gamma distribution.\nŒ≤::T: The rate parameter of the gamma distribution.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.MvNormalWishart","page":"Library","title":"ExponentialFamily.MvNormalWishart","text":"MvNormalWishart{T, M <: AbstractArray{T}, V <: AbstractMatrix{T}, K <: Real, N <: Real} <: ContinuousMatrixDistribution\n\nA multivariate normal-Wishart distribution, where T is the element type of the arrays M and matrices V, and K and N are real numbers. This distribution is a joint distribution of a multivariate normal random variable with mean Œº and a Wishart-distributed random matrix with scale matrix Œ®, degrees of freedom ŒΩ, and the scalar Œ∫ as a scaling parameter.\n\nFields\n\nŒº::M: The mean vector of the multivariate normal distribution.\nŒ®::V: The scale matrix of the Wishart distribution.\nŒ∫::K: The scaling parameter of the Wishart distribution.\nŒΩ::N: The degrees of freedom of the Wishart distribution\n\n\n\n\n\n","category":"type"},{"location":"library/#ExponentialFamily.FactorizedJoint","page":"Library","title":"ExponentialFamily.FactorizedJoint","text":"FactorizedJoint\n\nFactorizedJoint represents a joint distribution of independent random variables.  Use getindex() function or square-brackets indexing to access the marginal distribution for individual variables.\n\n\n\n\n\n","category":"type"},{"location":"library/#library-promotion-utilities","page":"Library","title":"Promotion type utilities","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"ExponentialFamily.paramfloattype\nExponentialFamily.sampletype\nExponentialFamily.samplefloattype\nExponentialFamily.promote_variate_type\nExponentialFamily.promote_paramfloattype\nExponentialFamily.promote_sampletype\nExponentialFamily.promote_samplefloattype\nExponentialFamily.convert_paramfloattype","category":"page"},{"location":"library/#ExponentialFamily.paramfloattype","page":"Library","title":"ExponentialFamily.paramfloattype","text":"paramfloattype(distribution)\n\nReturns the underlying float type of distribution's parameters.\n\nSee also: ExponentialFamily.promote_paramfloattype, ExponentialFamily.convert_paramfloattype\n\n\n\n\n\n","category":"function"},{"location":"library/#ExponentialFamily.sampletype","page":"Library","title":"ExponentialFamily.sampletype","text":"sampletype(distribution)\n\nReturns a type of the distribution. By default fallbacks to the eltype.\n\nSee also: ExponentialFamily.samplefloattype, ExponentialFamily.promote_sampletype, ExponentialFamily.promote_samplefloattype\n\n\n\n\n\n","category":"function"},{"location":"library/#ExponentialFamily.samplefloattype","page":"Library","title":"ExponentialFamily.samplefloattype","text":"samplefloattype(distribution)\n\nReturns a type of the distribution or the underlying float type in case if sample is Multivariate or Matrixvariate.  By default fallbacks to the deep_eltype(sampletype(distribution)).\n\nSee also: ExponentialFamily.sampletype, ExponentialFamily.promote_sampletype, ExponentialFamily.promote_samplefloattype\n\n\n\n\n\n","category":"function"},{"location":"library/#ExponentialFamily.promote_variate_type","page":"Library","title":"ExponentialFamily.promote_variate_type","text":"promote_variate_PromoteTypeConverter(::Type{ <: VariateForm }, distribution_type)\n\nPromotes (if possible) a distribution_type to be of the specified variate form.\n\n\n\n\n\n","category":"function"},{"location":"library/#ExponentialFamily.promote_paramfloattype","page":"Library","title":"ExponentialFamily.promote_paramfloattype","text":"promote_paramfloattype(distributions...)\n\nPromotes paramfloattype of the distributions to a single type. See also promote_type.\n\nSee also: ExponentialFamily.paramfloattype, ExponentialFamily.convert_paramfloattype\n\n\n\n\n\n","category":"function"},{"location":"library/#ExponentialFamily.promote_sampletype","page":"Library","title":"ExponentialFamily.promote_sampletype","text":"promote_sampletype(distributions...)\n\nPromotes sampletype of the distributions to a single type. See also promote_type.\n\nSee also: ExponentialFamily.sampletype, ExponentialFamily.samplefloattype, ExponentialFamily.promote_samplefloattype\n\n\n\n\n\n","category":"function"},{"location":"library/#ExponentialFamily.promote_samplefloattype","page":"Library","title":"ExponentialFamily.promote_samplefloattype","text":"promote_samplefloattype(distributions...)\n\nPromotes samplefloattype of the distributions to a single type. See also promote_type.\n\nSee also: ExponentialFamily.sampletype, ExponentialFamily.samplefloattype, ExponentialFamily.promote_sampletype\n\n\n\n\n\n","category":"function"},{"location":"library/#ExponentialFamily.convert_paramfloattype","page":"Library","title":"ExponentialFamily.convert_paramfloattype","text":"convert_paramfloattype(::Type{T}, distribution)\n\nConverts (if possible) the params float type of the distribution to be of type T.\n\nSee also: ExponentialFamily.paramfloattype, ExponentialFamily.promote_paramfloattype\n\n\n\n\n\nconvert_paramfloattype(::Type{T}, container)\n\nConverts (if possible) the elements of the container to be of type T.\n\n\n\n\n\n","category":"function"},{"location":"library/#library-statsfuns","page":"Library","title":"Extra stats functions","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"ExponentialFamily.mirrorlog\nExponentialFamily.xtlog\nExponentialFamily.logmvbeta\nExponentialFamily.clamplog\nExponentialFamily.mvtrigamma","category":"page"},{"location":"library/#ExponentialFamily.mirrorlog","page":"Library","title":"ExponentialFamily.mirrorlog","text":"mirrorlog(x)\n\nReturns log(1 - x).\n\n\n\n\n\n","category":"function"},{"location":"library/#ExponentialFamily.xtlog","page":"Library","title":"ExponentialFamily.xtlog","text":"xtlog(x)\n\nReturns x * log(x).\n\n\n\n\n\n","category":"function"},{"location":"library/#ExponentialFamily.logmvbeta","page":"Library","title":"ExponentialFamily.logmvbeta","text":"logmvbeta(x)\n\nUses the numerically stable algorithm to compute the logarithm of the multivariate beta distribution over with the parameter vector x.\n\n\n\n\n\n","category":"function"},{"location":"library/#ExponentialFamily.clamplog","page":"Library","title":"ExponentialFamily.clamplog","text":"clamplog(x)\n\nSame as log but clamps the input argument x to be in the range tiny <= x <= typemax(x) such that log(0) does not explode.\n\n\n\n\n\n","category":"function"},{"location":"library/#ExponentialFamily.mvtrigamma","page":"Library","title":"ExponentialFamily.mvtrigamma","text":"mvtrigamma(p, x)\n\nComputes multivariate trigamma function .\n\n\n\n\n\n","category":"function"},{"location":"library/#library-helpers","page":"Library","title":"Helper utilities","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"ExponentialFamily.vague\nExponentialFamily.logpdf_sample_optimized\nExponentialFamily.fuse_supports","category":"page"},{"location":"library/#ExponentialFamily.vague","page":"Library","title":"ExponentialFamily.vague","text":"vague(distribution_type, [ dims... ])\n\nvague function returns uninformative probability distribution of a given type.\n\n\n\n\n\n","category":"function"},{"location":"library/#ExponentialFamily.logpdf_sample_optimized","page":"Library","title":"ExponentialFamily.logpdf_sample_optimized","text":"logpdf_sample_optimized(distribution)\n\nlogpdf_sample_optimized function takes as an input a distribution and returns corresponding optimized two versions  for taking logpdf() and sampling with rand! respectively. By default returns the same distribution, but some distributions  may override default behaviour for better efficiency.\n\nExample\n\njulia> d = vague(MvNormalMeanPrecision, 2)\nMvNormalMeanPrecision(\nŒº: [0.0, 0.0]\nŒõ: [1.0e-12 0.0; 0.0 1.0e-12]\n)\n\n\njulia> ExponentialFamily.logpdf_sample_optimized(d)\n(FullNormal(\ndim: 2\nŒº: [0.0, 0.0]\nŒ£: [1.0e12 -0.0; -0.0 1.0e12]\n)\n, FullNormal(\ndim: 2\nŒº: [0.0, 0.0]\nŒ£: [1.0e12 -0.0; -0.0 1.0e12]\n)\n)\n\n\n\n\n\n","category":"function"},{"location":"library/#ExponentialFamily.fuse_supports","page":"Library","title":"ExponentialFamily.fuse_supports","text":"fuse_supports(left, right)\n\nFuse supports of two distributions of left and right. By default, checks that the supports are identical and throws an error otherwise. Can implement specific fusions for specific distributions.\n\nSee also: prod, ProductOf\n\n\n\n\n\n","category":"function"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#examples-product","page":"Examples","title":"Product of two probability distributions over the same variable","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we'll show you how to use the ExponentialFamily package to calculate the product of probability distributions that both relate to the same variable \"X\".  This operation results in another probability distribution, also centered around the variable \"X\".  It's essential to note that this is distinct from multiplying probability distributions for two different variables, such as \"X\" and \"Y\",  which yields a joint probability distribution. Calculating the product of two probability distributions over the same variable is a crucial step in applying Bayes' rule.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"p(Xvert D) propto underbracep(X)p(DX)_mathrmproductoftwodistributions","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To perform this operation, the ExponentialFamily library employs the prod function. This function takes a product strategy as its first argument. For instance:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using ExponentialFamily, Distributions\n\nprior = Bernoulli(0.5)\nlikelihood = Bernoulli(0.6)\n\nposterior = prod(PreserveTypeProd(Distribution), prior, likelihood)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"You can achieve the same result in the general exponential family form, which operates within the natural parameter space:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nef_prior = convert(ExponentialFamilyDistribution, prior)\nef_likelihood = convert(ExponentialFamilyDistribution, likelihood)\n\nef_posterior = prod(PreserveTypeProd(ExponentialFamilyDistribution), ef_prior, ef_likelihood)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Or even more concisely:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"prod(PreserveTypeProd(ExponentialFamilyDistribution), prior, likelihood)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, multiplying two Bernoulli distributions will always result in another Bernoulli distribution. However, this is not the case for all distributions. For instance, the product of two Laplace distributions may not yield another Laplace distribution, and representing the result in the same form might not be possible. In such cases, it's advisable to calculate the result within the exponential family domain. This is because the product of two exponential family distributions can always be represented as another exponential family distribution, as shown here:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nprior = Laplace(2.0, 3.0)\nlikelihood = Laplace(1.0, 4.0)\n\nprod(PreserveTypeProd(ExponentialFamilyDistribution), prior, likelihood)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that the result does not correspond to the Laplace distribution and returns a generic univariate ExponentialFamilyDistribution. This approach ensures consistency and compatibility, especially when dealing with a wide range of probability distributions.","category":"page"},{"location":"examples/#Computing-various-useful-attributes-of-an-exponential-family-member","page":"Examples","title":"Computing various useful attributes of an exponential family member","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The package implements attributes of many well known exponential family members, which are defined in this table. The attributes include getbasemeasure, getsufficientstatistics, getlogpartition, getfisherinformation, and others.  In general, the interface for these functions assumes a family member \"tag,\" such as Normal or Bernoulli. Here are some examples of how to use these attributes:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using ExponentialFamily, Distributions\n\n# Returns a function\nbasemeasure_of_normal = getbasemeasure(Normal)\n\nbasemeasure_of_normal(0.0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n# Returns an iterable of functions\nsufficientstatistics_of_gamma = getsufficientstatistics(Gamma)\n\nmap(f -> f(1.0), sufficientstatistics_of_gamma)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Some distributions, like the Laplace distribution, qualify as exponential family members only under certain conditions or when specific information is known in advance. In such cases, the ExponentialFamily package introduces the concept of a conditioner. For instance, the Laplace distribution becomes a member of the exponential family only when the location parameter is known and fixed. Consequently, we condition on the location parameter:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"laplace = Laplace(2.0, 1.0)\n\ncanonical = convert(ExponentialFamilyDistribution, laplace)\n\ngetconditioner(canonical)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# For conditioned distributions, the `conditioner` must be present as a second argument\nbasemeasure_of_laplace = getbasemeasure(Laplace, 2.0)\n\nbasemeasure_of_laplace(1.0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The getlogpartition and getfisherinformation functions optionally accept a space parameter as the first argument. This space parameter specifies the parameterization space, such as MeanParametersSpace or [NaturalParametersSpace]. The result obtained from these functions (in general) depends on the chosen parameter space:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"logpartition_of_gamma_in_mean_space = getlogpartition(MeanParametersSpace(), Gamma)\n\ngamma_parameters_in_mean_space = [ 1.0, 2.0 ]\n\nlogpartition_of_gamma_in_mean_space(gamma_parameters_in_mean_space)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"logparition_of_gamma_in_natural_space = getlogpartition(NaturalParametersSpace(), Gamma)\n\ngamma_parameters_in_natural_space = map(\n    MeanParametersSpace() => NaturalParametersSpace(), \n    Gamma,\n    gamma_parameters_in_mean_space\n)\n\nlogparition_of_gamma_in_natural_space(gamma_parameters_in_natural_space)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The same principle applies to the Fisher information matrix:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"fisherinformation_of_gamma_in_mean_space = getfisherinformation(MeanParametersSpace(), Gamma)\n\nfisherinformation_of_gamma_in_mean_space(gamma_parameters_in_mean_space)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"fisherinformation_of_gamma_in_natural_space = getfisherinformation(NaturalParametersSpace(), Gamma)\n\nfisherinformation_of_gamma_in_natural_space(gamma_parameters_in_natural_space)","category":"page"},{"location":"examples/#Approximating-attributes","page":"Examples","title":"Approximating attributes","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Refer to the ExpectationApproximations.jl package for approximating various attributes of the members of the exponential family.","category":"page"},{"location":"#ExponentialFamily.jl","page":"Home","title":"ExponentialFamily.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia package that extends the functionality of Distributions.jl by providing a collection of exponential family distributions and customized implementations. It is designed to facilitate working with exponential family distributions and offers specialized functionality tailored to this class of distributions.","category":"page"},{"location":"#Core-Principles","page":"Home","title":"Core Principles","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is built around several core principles:","category":"page"},{"location":"","page":"Home","title":"Home","text":"High performance with minimal allocations, striving for complete type stability.\nCompatibility with distributions defined in Distributions.jl.\nEase of use and rich functionality.","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Interface\nExamples\nLibrary","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
